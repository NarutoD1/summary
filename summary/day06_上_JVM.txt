JVM

面试题：
--请谈谈你对JVM的理解?java8的虚拟机有什么更新？
--什么是OOM？什么是StackOverflowError?有哪些方法分析？
--JVM的常用参数调优你知道哪些？
--内存快照抓取和MAT分析DUMP文件知道吗？
--谈谈JVM中，对类加载器你的认识？



1.JVM体系结构

	-a.类加载器（ClassLoader）
	
		将.class文件加载到运行时数据区，具体存放到方法区当中。
		
		4种类加载器
		-启动类加载器（Bootstrap）C++
		-扩展类加载器（Extension）Java
		-应用程序类加载器（AppClassLoader）Java
			也叫系统类加载器，加载当前应用的classpath的所有类
		-用户自定义加载器
			Java.lang.ClassLoader的子类，用户可以定制类的加载方式
		
		两种机制
		-双亲委派机制
			类的加载器从下至上层层关联，上一层是下一层的父类加载器
		
		-沙箱安全机制
			保护jdk中的类，防止用户对其中的类进行修改
	
	
	-b.执行引擎（Execution Engine）：负责解释命令，提交操作系统执行。
	
	
	类加载器、执行引擎相当于jvm的入口和出口
	
	-------------------------------------------------------------------------

	-c.本地方法栈、本地方法接口、本地方法库
	
	本地方法栈（是Native Method Stack）中存放的是native修饰的方法。
	
	
	本地方法接口：操作系统的接口
    
	本地方法库：若依赖的是java就是.jar文件，如果是Windows中的就是dll文件
	本地方法库以windows系统为例，指的就是dll文件（动态链接库）
	由native修饰的方法即是java处理不了的，需要调用本地方法接口。通过调用本地方法接口来执行本地方法栈中的方法，若需要第三方依赖就调用本地方法库。
	执行引擎执行时加载本地方法库来处理native方法
	
	一个问题：
		java编写的开启线程，线程是否开启是由操作系统决定的，因为Thread中的 start()是本地方法，表明java程序到这里已经无能为力，要开启线程，其实是给操作系统发送一个开启线程的请求，多线程的顺序也都是由操作系统决定的。
	-------------------------------------------------------------------------
	
	-d.程序计数器（PC寄存器）
	相当于一个指针，因为里面存储的是下一条要执行的指令的地址
	每个线程都有一个属于自己的程序计数器
	指令的读取由执行引擎完成
	
	占用内存特别少，无需考虑垃圾回收
	
	-e.java栈（stack） 先进后出
	每一个要执行的方法都以栈帧的形式存放在栈中，通过程序计数器指向要执行的对应方法的栈帧，方法执行完毕，栈帧出栈
	
	栈又称占内存，栈的生命周期和线程一致，只要线程结束，栈也跟着结束
	因此对于栈来说不存在垃圾回收问题
	
	java栈中存放的内容有：
	8中基本数据类型、对象的引用变量、实例方法
	
	栈溢出异常：
	**java.lang.StackOverflowerError
	导致原因：一直有方法入栈，不如方法的循环递归
	定位解决方法：根据日志定位出问题的代码，修改代码
	
	****************************************************************************
   	栈帧：是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，栈中的数据都是以栈帧的格式存在的。
	
	栈帧中包括：
	本地变量：输入参数、输出参数、方法内的变量
	栈操作：记录出栈、入栈的操作
	栈帧数据：:包括类文件、方法等等。
	
	-------------------------------------------------------------------------
	
	-f.方法区
	方法区被所有线程共享，属于共享区间
	
	方法区中存放所有与方法有关的信息包括：
	静态变量、常量、类信息（构造方法/接口定义）、运行时常量池
	
	**注意：实例变量存放在堆中
	
	栈、堆、方法区之间的交互关系：
	栈中存放的实例对象引用指向堆中存放的实例对象，堆中存放的实例对象，通过指针找到方法区中对应的对象信息
	
	三种jvm
	（jvm是一套java虚拟机规范）
	jdk商标
	Sun---HotSpot	
	BEA---JRockit(目前使用的jdk8中的jvm虽然还叫HotSpot但其实是BEA开发的)
	IBM---J9 VM
	
	-g.堆（heap）
	
	堆的逻辑结构：（物理内存：只有新生区和养老区）
	
	jdk7及之前
	--新生代（Young Generation Space/Young）
		--伊甸区（Eden）
			存放新创建的实例对象，存活率低。
		--幸存0区（S0）
		--幸存1区（S1）
			
		Eden:S0:S1=8:1:1
		
	--老年代（Tenure generation space/Old/Tenure）
	--永久存储区（Permanent Space/Perm）
		是一个常驻内存的区域，用于存放JDK自身所携带的Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭 JVM 才会释放此区域所占用的内存。

	**不同版本jdk中堆的区别
	
	Jdk1.6及之前： 有永久代, 常量池1.6在方法区
	Jdk1.7： 有永久代，但已经逐步“去永久代”，常量池1.7在堆
	Jdk1.8及之后： 无永久代，常量池1.8在元空间
	新创建的实例对象存放在Eden区中，当Enden的空间占用到了70%--80%左右是，将经过一次gc，幸存下来的对象转移到S0中；若S0也满了，再次进行gc，幸存下来的对象转移到S1；若S1也满了，再次gc，幸存下来的对象再次转移到S0，而不是转移到养老区，默认情况下是经过15次gc，仍能够存活下来的对象将注意到养老区，说明此对象使用频繁，例如池对象（数据库连接池，线程池）。在这15次gc中S0和S1交替充当from区和to区，to区始终是空的那一个
	
	在新生代区域的gc是轻量级的，称为Minor GC
	
	如果养老区也快满了，触发gc此时的gc称为FullGC（MajorGC）,如果FullGC回收内存失败，那么将会出现异常：
	java.lang.OutOfMemoryError  简称OOM
	
	如果Eden中要转移到幸存区中的对象所占空间大于幸存区的空间那么会触发应急机制，Eden区的对象将直接注意到养老区，此时也就不会出现15次gc。
	
	
	养老区和永久区是非连通的
	
	1）java.lang.OutOfMemoryError:java heap space
	该异常由堆空间报出表明堆内存不足
	
	一般该错误出现在生产环境
	**定位该错误方式：通过MAT分析DUMP文件定位问题
	
	如何解决问题：
	--Java虚拟机的堆内存设置不够，设置参数-Xms -Xmx 来调整 
	--代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。需要对代码进行优化。
	
	2）java.lang.OutOfMemoryError: PermGen space
	说明是Java虚拟机对永久代Perm内存设置不够。一般出现这种情况，都是程序启动需要加载大量的第三方jar包。例如：在一个Tomcat下部署了太多的应用。或者大量动态反射生成的类不断被加载，最终导致Perm区被占满。
	
	但目前已经遇不到这种错误了，因为Maven对jar包的管理，通过配置好相关的配置，由Maven去找相关的jar包，更何况jdk8已经没有永久区了。
	
	
	内存调优:
	
	1）首先定位问题出在哪里：设置运行参数，生成dump文件
		通过专业工具比如eclipse的MAT、jdk自带的jvisualvm.exe分析dump文件定位问题出处
	2）如果是内存不够，就修改jvm参数，修改初始化内存和占用最大内存
	3）如果是代码问题就修改代码
	
	
	
	
	
	
	
	