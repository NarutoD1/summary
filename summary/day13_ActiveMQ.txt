ActiveMQ

0.集群和分布式
分布式：多个服务，做不同的事，完成同一个项目
集群：所有的服务做同一件事（可能是项目的一个功能）

1.中间件
	位于应用系统和系统软件之间的一类软件，用于分布式系统中，用于共享资源
	数据库中间件--mycat，web服务中间件--tomcat，消息中间件--activemq 等的

2.微服务架构存在的问题
	-1.系统之间接口耦合比较严重
		每新增一个下游功能，都要对上游的相关接口进行改造
	-2.面对大流量并发时，容易被冲垮
		当面对高访问量，高并发容易被冲垮
	-3.等待同步存在性能问题
		RPC接口基本上是同步调用，模块与模块之间的调用依赖，使整个系统遵循木桶效应，整体系统的耗时取决于链路中最慢的那个接口。
3.要解决问题
	-1.解耦
	   要做到系统解耦，当新的模块接进来时，可以做到代码改动最小；
	-2.削峰
	   设置流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲垮；
	-3.异步
	   强弱依赖梳理能将非关键调用链路的操作异步化并提升整体系统的吞吐能力；
		
4.面向消息的中间件（OMO）
	
	是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。
	通过提供消息传递和消息排队模型在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等功能。
		
5.解决三大问题的原理

	-1.解耦
		发送者和接受者不必了解对方，只需要确认消息
		发送者和接受者不必同时在线
		以双11秒杀为例，只要用户支付生成订单，数据写入数据库，就立马生成消息返回给用户，用户无需等待通知，无需等待缓存更新。
		将与用户有关的服务和需要在后台等待处理的服务分开，提高系统及时响应用户的时效性。
	
	-2.削峰
		使用消息队列，让并行改为串行，所有的请求需要在队列中排队等待服务
		
	-3.异步
		发送消息的一方只关注成功发送消息给消息服务器，不关注消息接收方怎么处理消息，是否成功处理完毕。异步的方式也达到了解耦的效果
	
	MQ的弊端：mq具有延迟性这一弊端
	
6.安装ActiveMQ
	-1.上传安装包到/opt目录下
	-2.解压  tar -zxvf apache-activemq-5.15.9-bin.tar.gz
	-3.在/下创建文件夹myactivemq
	-4.递归拷贝activemq的文件夹 到 myactivemq下（方便以后的测试配置）
		cp -r apache-activemq-5.15.9 /myactivemq/
	-5.启动activemq
		--普通启动：进入bin目录下，./activemq start
		--带运行日志的启动方式：./activemq start > /myactivemq/run_mq.log
	-6.关闭activemq ./activemq stop
	
	
7.JMS编码总体架构

	1）.destination为queue
		-1.创建连接工厂对象
		-2.通过工厂对象创建连接对象
		-3.通过连接对象创建session对象
			其中两个参数：是否开启事务、指定消息签收方式
			
		-4.创建队列（即destination目的地）
		-5.创建消息生产者和消息消费者（在这里分支）
			--创建消息生产者对象·
				1.创建生产者对象并指定队列
				2.创建消息
				3.生产者发送消息
			
			--创建消息消费者对象
				1.创建消费者对象并指定队列
				2.创建消息对象并接收消息
					---1.同步阻塞方式
						TextMessage textMessage=null;
					
						while (true) {
					
							//recive()与recive(long t)的区别
							//recive()方法属于不见不散，如果队列中没有消息将一直阻塞知道队列中有消息来到
							//recive(long t)属于过时不候，当超过规定的超时时间，将断开与mq的连接
							textMessage= (TextMessage) consumer.receive();
				
							if (textMessage!=null) {
				
								System.out.println("消费者接收消息-------"+textMessage.getText());
				
							} else {
				
								break;
				
						   }
					
						}
			
					---2.异步非阻塞方式
						consumer.setMessageListener(new MessageListener() {
							@Override
							public void onMessage(Message message) {

								if (message instanceof TextMessage){

									try {

										String text = ((TextMessage) message).getText();
										System.out.println("消费者接收消息----"+text);

									} catch (JMSException e) {
										e.printStackTrace();
									}

								}


							}
						});
						
						//异步方式需要注意一点的是：利用监听器扫描，扫描一次后，连接关闭
						//由于mq具有延迟性这一弊端，并不能保证能够监听器扫描一次就能扫描到消息
						//因此需要一种措施使监听器扫描不止一次
						//这里采用让其线程有多久睡多久的方法   TimeUnit.SECONDS.sleep(Long.MAX_VALUE);
			
		-6.依次关闭资源：生产者/消费者、session、connection
		
		
	2）destination为topic
		
		与采用queue不同点在：
		topic不会保存消息，因此需要先启动消费者，再启动生产者。但这样生产者和消费者具有了时间上的关联。
		只有订阅了主题的消费者，才能收到该主题中的消息，有多个生产者订阅了该主题，那么这些生产者都会收到该主题中的消息
	
8.关于消息的消费问题
	-1.消息不能重复消费
		先启动生产者生产消息，才启动多个消费者消费，只有第一个访问mq的消费者消费队列中所有的消息，其余的消费者接收消息。
	
	-2.mq对消息消费有自动负载均衡的机制
		先启动多个消费者访问mq，在启动一个生产者向mq发送消息，那么这些消息将自动被mq均分到到每个消费者
	
	
9.JMS规范
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	